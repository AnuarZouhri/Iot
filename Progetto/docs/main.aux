\relax 
\providecommand\babel@aux[2]{}
\@nameuse{bbl@beforestart}
\providecommand\hyper@newdestlabel[2]{}
\providecommand\HyField@AuxAddToFields[1]{}
\providecommand\HyField@AuxAddToCoFields[2]{}
\babel@aux{italian}{}
\babel@aux{italian}{}
\@writefile{toc}{\contentsline {section}{\numberline {1}Introduzione}{2}{section.1}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {2}Architettura del Sistema}{2}{section.2}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {3}Descrizione del Codice}{2}{section.3}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {3.1}File: \texttt  {main.py}}{2}{subsection.3.1}\protected@file@percent }
\@writefile{lol}{\contentsline {lstlisting}{\numberline {1}{\ignorespaces Il main del programma è stato sviluppato come un automa a stati a finiti e qui sono rappresentati i vari stati. Lo stato di configurazione pin è lo stato che viene eseguito alla prima esecuzione del programma: qui viene configurato il file contenente il pin d'accesso al caveaux. Lo stato di configurazione wifi è eseguito sequenzialmente a quello di configurazione pin. Lo stato di connessione permette la connessione all'MQTT. Finiti i vari step di connessione si accede allo stato di vista menu, in cui vengono riportati parametri interni al caveaux, quali temperatura e umidità, ed è inoltre possibile scegliere di accedere al caveaux o di cambiare configurazione. Entrambe le opzioni appena descritte vengono eseguite in appositi stati: stato di inserimento pin e stato di cambio configurazione. Una volta sbloccato il caveaux si entra nello stato sbloccato. In caso di intrusione o valori di temperatura e umidità fuori norma si entra nello stato di allarme.}}{2}{lstlisting.1}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {3.2}File: \texttt  {Handler.py}}{4}{subsection.3.2}\protected@file@percent }
\@writefile{lol}{\contentsline {lstlisting}{\numberline {2}{\ignorespaces Questa classe gestisce la lettura del sensore ad ultrasuoni (hcsr04) e del sensore di umidità e temperatura (dht22) e il controllo che i valori letti siano minori di una certa soglia. Il costruttore inizializza le soglie con i valori imposti alla precedente esecuzione (leggendo da file) o tramite parametri di input. I metodi read() e check() permettono rispettivamente la lettura dei valori e il loro controllo. È inoltre possibile modificare le soglie tramite metodi set().}}{4}{lstlisting.2}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {3.3}File: \texttt  {MQTTClass.py}}{6}{subsection.3.3}\protected@file@percent }
\@writefile{lol}{\contentsline {lstlisting}{\numberline {3}{\ignorespaces Questa classe gestisce la creazione del client MQTT. Il costruttore inizializza i vari topic e altre variabili di connessione quali indirizzo ip del broken e id del client. Infine inizializza l'oggetto client impostando la funzione di callback inviata come parametro di input. Il metodo checkAndReadMsg() pubblica i valori letti dal sensore di umidità e temperatura e risolve eventuali problemi di connessione.}}{6}{lstlisting.3}\protected@file@percent }
\gdef \@abspage@last{9}
